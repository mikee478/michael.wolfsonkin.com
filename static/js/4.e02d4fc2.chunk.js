(this["webpackJsonpreact-tailwindcss-portfolio"]=this["webpackJsonpreact-tailwindcss-portfolio"]||[]).push([[4],{56:function(e,t,i){"use strict";t.a=i.p+"static/media/drift-simulation.796241d7.png"},57:function(e,t,i){"use strict";t.a=i.p+"static/media/ascii-camera.79af2d26.mp4"},58:function(e,t,i){"use strict";i.d(t,"a",(function(){return C}));var a=i(56),r=i.p+"static/media/drift-simulation-poster.69885f95.png",o=i.p+"static/media/drift-simulation.0c477177.mp4",s=i.p+"static/media/cube-solver.555a9c20.png",n=i.p+"static/media/cube-solver-poster.555a9c20.png",c=i.p+"static/media/cube-solver.9d9adb22.mp4",l=i.p+"static/media/ray-tracer-island.0ea768c6.png",d=i.p+"static/media/ray-tracer-duck.7ff59119.png",h=i.p+"static/media/flocking-simulation.ccbfe455.png",p=i.p+"static/media/flocking-simulation-poster.454e6e26.png",g=i.p+"static/media/flocking-simulation.0faa1114.mp4",u=i.p+"static/media/polygon-utilities.97c96d80.png",m=i.p+"static/media/polygon-utilities-poster.64b49e97.png",b=i.p+"static/media/polygon-utilities.1fc7438a.mp4",f=i.p+"static/media/ascii-camera.cb93aa8a.png",v=i.p+"static/media/ascii-camera-zoomed.5efc98c4.png",y=i.p+"static/media/ascii-camera-poster.4115fcba.png",j=i(57),w=i.p+"static/media/interactive-quadtree.a5ea5dce.png",_=i.p+"static/media/interactive-quadtree-poster.f067d7f8.png",x=i.p+"static/media/interactive-quadtree.a9b1d682.mp4",k=i.p+"static/media/raindrop-simulation.f5ac694d.png",O=i.p+"static/media/raindrop-simulation-poster.48d71159.png",P=i.p+"static/media/raindrop-simulation.6909d25e.mp4",C=[{title:"Drift Simulation",category:"",cover_image:a.a,url_id:"drift-simulation",publish_date:"March 2023",page_images:[],page_videos:[{poster:r,video:o}],technologies:["C++","OpenGL","GLSL"],project_details:["The drift simulation uses 3D Perlin noise to randomly generate a landscape of colors and shapes that evolves over time. This project is inspired by the macOS Drift screensaver. Each line's rotation, length, width, and color are derived from 3D Perlin noise implemented in the shaders."],github_link:"https://github.com/mikee478/drift-simulation"},{title:"Rubik's Cube Solver",category:"",cover_image:s,url_id:"rubiks-cube-solver",publish_date:"September 2019",page_images:[],page_videos:[{poster:n,video:c}],technologies:["Python","PyQt","OpenGL"],project_details:["Working alongside two talented students, the virtual Rubik's cube solver was developed in just 24 hours during the Stony Brook University 2019 hackathon, SBUHacks 2019. Our Rubik's cube solver utilizes the popular CFOP (Cross, F2L, OLL, PLL) method for solving the cube. We took on this challenge and were able to solve the Rubik's cube in an average of just 90 moves."],github_link:"https://github.com/mikee478/cube-solver"},{title:"Ray Tracer",category:"",cover_image:l,url_id:"ray-tracer",publish_date:"December 2022",page_images:[d,l],page_videos:[],technologies:["C++","OpenCV"],project_details:["Capable of producing realistic images by tracing the path of light rays as they interact with objects in a scene.","Implemented Phong shading, shadows, antialiasing, reflection, refraction, mesh rendering, texture mapping, and bounding volume hierarchy."],github_link:""},{title:"Flocking Simulation",category:"",cover_image:h,url_id:"flocking-simulation",publish_date:"March 2023",page_images:[],page_videos:[{poster:p,video:g}],technologies:["C++","OpenGL","GLSL"],project_details:["The Boids simulation is a computer program that simulates the flocking behavior of birds, fish, or other animals. It was first introduced by computer scientist Craig Reynolds in 1986.",'The simulation models the behavior of individual animals as "boids" (short for bird-oids). Each boid follows three simple rules:',"-Separation: Avoid collisions with nearby boids","-Alignment: Align with the average direction of nearby boids","-Cohesion: Move towards the average position of nearby boids","These rules are implemented by calculating the forces that act on each boid based on the positions and velocities of nearby boids, and updating the position and velocity of each boid accordingly. By following these rules, the boids can exhibit complex and realistic flocking behavior.","The Boids simulation has found applications in a variety of fields, including robotics, computer graphics, and artificial intelligence. It has been used to design autonomous robots that can navigate and communicate with each other, to create realistic simulations of crowds and traffic, and to study the behavior of social animals such as ants and bees."],github_link:"https://github.com/mikee478/boids"},{title:"ASCII Camera",category:"",cover_image:f,url_id:"ascii-camera",publish_date:"March 2023",page_images:[v],page_videos:[{poster:y,video:j.a}],technologies:["C++","OpenGL","GLSL"],project_details:["An ASCII camera is a type of camera that captures images using ASCII characters instead of pixels. ASCII stands for American Standard Code for Information Interchange, which is a character encoding system used to represent text in computers. ASCII cameras work by converting the light and dark areas of an image into different ASCII characters. Each character represents a different shade of gray, ranging from light to dark. The resulting image would be a grid of ASCII characters, with each character representing a different shade of gray. While ASCII cameras are no longer commonly used for photography, they remain a popular tool for creating ASCII art, which is a form of digital art made entirely out of ASCII characters."],github_link:"https://github.com/mikee478/ascii-camera"},{title:"Raindrop Simulation",category:"",cover_image:k,url_id:"raindrop-simulation",publish_date:"June 2023",page_images:[],page_videos:[{poster:O,video:P}],technologies:["Python","OpenCV","NumPy"],project_details:["The Raindrop Simulation project is a captivating, yet simple implementation of water dynamics, based on Hugo Elias' article titled \"2D Water.\" This simulation offers a mesmerizing visual representation of raindrops interacting with a 2D grid that represents the water's height at various locations. What makes this simulation unique is its ability to achieve realistic water movement without the use of trigonometric functions or differential equations.","At its core, the simulation employs a straightforward yet effective approach to update the water's height and simulate its behavior. The 2D grid serves as a canvas where the height of the water is depicted at each discrete location. The simulation dynamically evolves by iterating over each grid cell, recalculating the water's height based on neighboring cells and estimated velocity.","To update the water's height at a particular grid cell, the simulation computes the average height of its neighboring cells. This collective average serves as a foundation for the height update. Additionally, the simulation introduces the concept of estimated velocity, which is determined by subtracting the current height from the previous height. By incorporating this velocity component, the simulation emulates the movement and flow of water.","The utilization of the average height of neighboring cells, coupled with the estimated velocity, results in a visually striking representation of raindrop behavior. As raindrops interact with the grid, their impact creates ripples that propagate and merge with adjacent ripples, producing an intricate and captivating water simulation.","Furthermore, this project offers the flexibility to explore alternative methods beyond averaging the heights of neighboring cells, enabling the generation of unique visual effects. By incorporating different averaging techniques, the simulation can create a wave-like behavior in the water. These waves can propagate through the grid, interacting with the raindrops and producing mesmerizing patterns. Additionally, by experimenting with alternative approaches, the simulation can also achieve abstract artistic effects, transforming the representation of water into a visually captivating and imaginative display."],github_link:"https://github.com/mikee478/raindrop-simulation"},{title:"Polygon Utilities",category:"",cover_image:u,url_id:"polygon-utilities",publish_date:"November 2022",page_images:[],page_videos:[{poster:m,video:b}],technologies:["Python","PyGame"],project_details:["A simple tool to build simple polygons!","Includes counter clockwise testing, self-intersection testing, point in polygon testing (winding number, ray casting), ear clipping triangulation, sample points within a polygon (rejection sampling, triangulation sampling), convex hull algorithms (gift wrapping, Graham's scan), and visibility polygon"],github_link:"https://github.com/mikee478/polygon-utilities"},{title:"Interactive Quadtree",category:"",cover_image:w,url_id:"interactive-quadtree",publish_date:"November 2022",page_images:[],page_videos:[{poster:_,video:x}],technologies:["Python","PyGame","NumPy"],project_details:["A point quadtree is a data structure used to store and efficiently search for points in a two-dimensional space. It is a hierarchical tree structure where each node represents a square region in the space, and points are stored at the leaf nodes of the tree.","Each node in the tree has four children, corresponding to the four quadrants of the square region represented by the node. The tree is built recursively by subdividing each square region into four smaller squares until each leaf node contains at most one point.","To search for a point in the quadtree, the search starts at the root node and recursively descends the tree, choosing the appropriate child node at each level based on the quadrant in which the search point lies. The search terminates when a leaf node containing the point is reached or when an empty node is encountered.","Point quadtree is commonly used in various applications such as geographic information systems, computer graphics, and computer vision. It provides an efficient way to search for nearest neighbors, range search, and spatial indexing."],github_link:"https://github.com/mikee478/interactive-quadtree"}]},63:function(e,t,i){"use strict";i.r(t);var a=i(0),r=i(54),o=i(13),s=i(3),n=function(e){var t=e.project;return Object(s.jsx)(r.a.div,{initial:{opacity:0},animate:{opacity:1,delay:1},transition:{ease:"easeInOut",duration:.7,delay:.15},children:Object(s.jsx)(o.b,{to:"/projects/"+t.url_id,"aria-label":t.title,children:Object(s.jsxs)("div",{className:"rounded-xl shadow-lg hover:shadow-xl cursor-pointer mb-10 sm:mb-0 bg-secondary-light dark:bg-ternary-dark",children:[Object(s.jsx)("div",{children:Object(s.jsx)("img",{src:t.cover_image,className:"rounded-t-xl border-none",alt:t.title})}),Object(s.jsxs)("div",{className:"text-center px-4 py-6",children:[Object(s.jsx)("p",{className:"font-general-medium text-lg md:text-xl text-ternary-dark dark:text-ternary-light mb-2",children:t.title}),Object(s.jsx)("span",{className:"text-lg text-ternary-dark dark:text-ternary-light",children:t.category})]})]})})})},c=i(6),l=i(58),d=Object(a.createContext)(),h=function(e){var t=Object(a.useState)(l.a),i=Object(c.a)(t,2),r=i[0],o=i[1],n=Object(a.useState)(""),h=Object(c.a)(n,2),p=h[0],g=h[1],u=Object(a.useState)(""),m=Object(c.a)(u,2),b=m[0],f=m[1],v=r.filter((function(e){return e.title.toLowerCase().includes(p.toLowerCase())||""===p?e:""})),y=r.filter((function(e){return(e.category.charAt(0).toUpperCase()+e.category.slice(1)).includes(b)}));return Object(s.jsx)(d.Provider,{value:{projects:r,setProjects:o,searchProject:p,setSearchProject:g,searchProjectsByTitle:v,selectProject:b,setSelectProject:f,selectProjectsByCategory:y},children:e.children})},p=function(){var e=Object(a.useContext)(d),t=e.projects,i=e.searchProject,r=(e.setSearchProject,e.searchProjectsByTitle),o=e.selectProject,c=(e.setSelectProject,e.selectProjectsByCategory);return Object(s.jsxs)("section",{className:"py-5 sm:py-10 mt-5 sm:mt-10",children:[Object(s.jsx)("div",{className:"text-center",children:Object(s.jsx)("p",{className:"font-general-medium text-2xl sm:text-4xl mb-1 text-ternary-dark dark:text-ternary-light",children:"Projects Portfolio"})}),Object(s.jsx)("div",{className:"mt-10 sm:mt-16"}),Object(s.jsx)("div",{className:"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 mt-6 sm:gap-10",children:o?c.map((function(e,t){return Object(s.jsx)(n,{project:e},t)})):i?r.map((function(e,t){return Object(s.jsx)(n,{project:e},t)})):t.map((function(e,t){return Object(s.jsx)(n,{project:e},t)}))})]})};t.default=function(){return Object(s.jsx)(h,{children:Object(s.jsx)("div",{className:"container mx-auto",children:Object(s.jsx)(p,{})})})}}}]);
//# sourceMappingURL=4.e02d4fc2.chunk.js.map